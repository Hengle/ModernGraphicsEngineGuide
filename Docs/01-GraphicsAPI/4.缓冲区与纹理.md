# 缓冲区与纹理

## 缓冲区

缓冲区（Buffer）持有一段GPU上的内存（Memory）以及一些相关参数（**类型（Type）** 和 **用途（Usage）**）

**类型（Type）** 决定的Buffer的存储特性，图形API一般将其划分为：

- **Host Local Memory** ：只对Host可见的内存，通常称之为普通内存
- **Device Local Memory** ：只对Device可见的内存，通常称之为显存
- **Host Local Device Memory** ：由Host管理的，对Device看见的内存
- **Device Local Host Memory** ：由Device管理的，对Host可见的内存

> Host 往往是 CPU端， Device 指 GPU 端

关于细节，请查阅：

- [Vulkan 内存管理](https://zhuanlan.zhihu.com/p/166387973)

使用合适的内存类型能大幅提升内存的读写效率，在现代图形引擎中的流水线中，会尽可能地使用 **Device Memory** ，当我们要从CPU中提交数据给它时，由于Host无法访问，一般会将数据上传到一个 **Host可见的Memroy** 上，再通过指令拷贝到对应的 **Device Memory** 上，我们一般称这个持有主机可见内存的Buffer为 [Staging Buffer](https://link.zhihu.com/?target=https%3A//vulkan-tutorial.com/Vertex_buffers/Staging_buffer)

在 **用途（Usage）** 上，Buffer 通常可具备以下 **标识（Flag）** ：

- **VertexBuffer** ：用于存放顶点数据
- **IndexBuffer** ：用于存放索引数据
- **UniformBuffer** ：用于存储常量数据
- **StorageBuffer** ：用于Compute管线中的数据计算
- **IndirectDrawBuffer** ：用于间接渲染提供渲染参数

在图形渲染管线章节中，我们使用QRhi很轻松地创建了一个用于存储顶点数据的缓冲区（**VertexBuffer**）：

``` c++
QScopedPointer<QRhiBuffer> mVertexBuffer;   
mVertexBuffer.reset(mRhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(VertexData)));
mVertexBuffer->create(); //在QRhi中，调用渲染资源对象的create函数才实际创建对应的GPU资源，在这之前，我们都是调整参数状态机而已
```

只需要使用函数newBuffer就能申请一个新的缓冲区：

```c++
QRhiBuffer* QRhi::newBuffer(QRhiBuffer::Type type,
                      		QRhiBuffer::UsageFlags usage,
                      		quint32 size);
```

函数参数所代表的意义如下：

- **Type**：Buffer的类型，决定了Buffer的存储特性。

  - **Immutable** ：用于存放希望永远不会发生改变的数据，具有非常高效的GPU读写性能，它通常放置在 **Devices Local** 的 GPU 内存上，无法被CPU直接读写，但QRhi却支持它的上传，其原理是：每次上传数据新建一个 **Host Local** 的 **Staging Buffer** 作为中转来上传新数据，这样操作的代价是非常高昂的。

  - **Static** ：同样存储在 **Devices Local** 的 GPU 内存上，与 Immutable 不同的是，首次上传数据创建的 **Staging Buffer** 会一直保留。

  - **Dynamic** ：用于存放频繁发生变化的数据，它放置 **Host Local** 的GPU内存中，为了不拖延图形渲染管线，它通常会使用双缓冲机制。

- **Usage**：Buffer的用途，`Flags`说明是可以使用运算符`|`让多个`Flag`共存

  - **VertexBuffer**：表明该Buffer可作为顶点缓冲区，存储顶点数据，作为图形渲染管线的输入
  - **IndexBuffer**：表明该Buffer可作为索引缓冲区，存储索引数据，用于挑选顶点数据
  - **UniformBuffer**：表明该Buffer可作为Uniform缓冲区，存储Uniform数据，作为着色器的公共输入
  - **StorageBuffer**：表明该Buffer可作为Storage缓冲区，该缓冲区可被计算着色器读写

- **Size**：Buffer的事情大小（单位为字节）

### 顶点缓冲区

**顶点缓冲区（VertexBuffer）** 用作流水线的输入

在QRhi中，体现在录制渲染指令时必须为图形渲染管线指定顶点输入：

```c++
cmdBuffer->setGraphicsPipeline(mPipeline.get());							
cmdBuffer->setViewport(QRhiViewport(0, 0, mSwapChain->currentPixelSize().width(), mSwapChain->currentPixelSize().height()));
cmdBuffer->setShaderResources();										
const QRhiCommandBuffer::VertexInput vertexInput(mVertexBuffer.get(), 0);	//将 mVertexBuffer 绑定到Buffer0，内存偏移值为0
cmdBuffer->setVertexInput(0, 1, &vertexInput);								
cmdBuffer->draw(3);															
```

而在创建流水线的时候，必须为流水线设置**顶点输入布局（VertexInputLayout）**，它用于制定缓冲区的解析规则，在之前的章节中，我们使用了这样的顶点数据：

``` c++
static float VertexData[] = {										//顶点数据
	//position(xy)		color(rgba)
	 0.0f,  -0.5f,		1.0f, 0.0f, 0.0f, 1.0f,
	-0.5f,   0.5f,		0.0f, 1.0f, 0.0f, 1.0f,
	 0.5f,   0.5f,		0.0f, 0.0f, 1.0f, 1.0f,
};
```

为了让顶点数据能够被下面的 顶点着色器输入 使用：

``` glsl
layout(location = 0) in vec2 position;	
layout(location = 1) in vec4 color;
```

我们可以定义这样的顶点输入布局：

``` c++
QRhiVertexInputLayout inputLayout;
inputLayout.setBindings({		 //定义每个VertexBuffer单组顶点数据的跨度，这里只使用了一个VertexBuffer
    //这里是6*sizeof(float)，可以当作是GPU会从索引为0的Buffer中读取24字节数据作为单组顶点数据传给VertexShader
    QRhiVertexInputBinding(6 * sizeof(float)) 
});

inputLayout.setAttributes({
    //在从Buffer 0得到的单组顶点数据中，以偏移值为0，读取Float2大小的数据作为 location 0 的输入
    QRhiVertexInputAttribute(0, 0 , QRhiVertexInputAttribute::Float2, 0),
   
    //在从Buffer 0得到的单组顶点数据中，以偏移值为sizeof(float)*2，读取Float4大小的数据作为 location 1 的输入
    QRhiVertexInputAttribute(0, 1 , QRhiVertexInputAttribute::Float4, sizeof(float) * 2),	
});
```

在图形渲染的处理过程中，计算机关注的只是内存上的数据，并不在意这些数据的象征意义，正因为顶点输入布局的存在，使得我们可以编程时自行组织顶点的存储结构。

上面我们将所有的数据都放在了一个`float数组`中，现在我们可以使用一个更直观的结构：

``` c++
struct Vertex{					//顶点的结构
	QVector2D position;
	QVector4D color;
};
QVector<Vertex> vertices = {	//顶点数据
    { { 0.0f,  -0.5f},	{1.0f, 0.0f, 0.0f, 1.0f	}},
    { {-0.5f,   0.5f},	{0.0f, 1.0f, 0.0f, 1.0f	}},
    { { 0.5f,   0.5f},	{0.0f, 0.0f, 1.0f, 1.0f	}},
};
```

我们只需填充顶点数据，使用`sizeof(Vertex) * vertices.size()`创建顶点缓冲区：

```c++
QScopedPointer<QRhiBuffer> vertexBuffer;   
vertexBuffer.reset(mRhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(Vertex) * vertices.size()));
vertexBuffer->create(); 
```

并使用这样的顶点输入布局：

```c++
QRhiVertexInputLayout inputLayout;
inputLayout.setBindings({	
    QRhiVertexInputBinding(sizeof(Vertex)) 		//单个顶点数据的跨度也就是Vertex结构的大小
});

inputLayout.setAttributes({
    QRhiVertexInputAttribute(0, 0 , QRhiVertexInputAttribute::Float2, offsetof(Vertex,position)),
    QRhiVertexInputAttribute(0, 1 , QRhiVertexInputAttribute::Float4, offsetof(Vertex,color)),	
});
```

> **offsetof**运算符可用于获取成员变量在结构体或类中的内存偏移

上传时使用数组的裸数据即可：

```c++
batch->uploadStaticBuffer(mVertexBuffer.get(), mVertices.data());
```

### 索引缓冲区

**索引缓冲区（IndexBuffer）**用于挑选输入到流水线中的顶点数据

一个通用的应用场景是：

- 由于图形API支持的基础图元只有点，线和三角形，在绘制多边形的时候，会使用多个三角形进行拼接，以四边形为例，一个四边形可划分为两个三角形，而两个三角形有六个顶点，但实际上四边形只有四个顶点，如果使用三角形拼接，会需要浪费两个顶点数据的空间大小来存储重叠的顶点，所有我们需要一种策略，来复用顶点缓冲区中的顶点数据，以完成 使用四个顶点就能绘制出由两个三角形组成的四边形。

流水线处理顶点输入时，会根据顶点输入布局，将顶点缓冲区中的数据划分成一组组有序的顶点数据，在**默认情况**下，会将这些顶点数据都交给VertexShader进行处理。

而索引缓冲区的作用，就是在划分成一组组有序的顶点数据之后，通过一系列索引（Index），在原先的顶点数据上进行挑选，组装出新的顶点数据交给VertexShader处理。

假如我们使用这样的顶点数据：

``` c++
static float VertexData[] = {
	//position(xy)
	 1.0f,   1.0f,
	 1.0f,  -1.0f,
	-1.0f,  -1.0f,
	-1.0f,   1.0f,	
};
```

可以使用这样的索引数据，从上述顶点中，使用6个索引来组装新的顶点数据：

```c++
static uint32_t IndexData[] = {
	0,1,2,
	2,3,0
};
```

与VertexBuffer一样，我们只需创建一个IndexBuffer：

```c++
QScopedPointer<QRhiBuffer> mIndexBuffer;
mIndexBuffer.reset(mRhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::IndexBuffer, sizeof(IndexData)));
mIndexBuffer->create();
```

并在首次录制渲染指令时提交索引数据：

```c++
batch->uploadStaticBuffer(mIndexBuffer.get(), IndexData);
```

渲染指令变成了：

```c++
cmdBuffer->setGraphicsPipeline(mPipeline.get());
cmdBuffer->setViewport(QRhiViewport(0, 0, mSwapChain->currentPixelSize().width(), mSwapChain->currentPixelSize().height()));
cmdBuffer->setShaderResources();
const QRhiCommandBuffer::VertexInput vertexBindings(mVertexBuffer.get(), 0);

//指定IndexBuffer，并明确IndexBuffer使用UInt32格式的索引数据
cmdBuffer->setVertexInput(0, 1, &vertexBindings, mIndexBuffer.get(), 0, QRhiCommandBuffer::IndexUInt32);  

//使用drawIndexed而不是draw，这样渲染会从IndexBuffer中，读取6个索引，利用顶点缓冲区中数据组装出6个顶点，来绘制三角形
cmdBuffer->drawIndexed(6);
```

### Uniform 缓冲区

**Uniform 缓冲区（Uniform Buffer）**用于给流水线提供一些公共的输入参数





### Storage 缓冲区

## 纹理

### 采样器



## 内存管理

- Vulkan中应该做和不应该做的事情：https://developer.nvidia.com/blog/vulkan-dos-donts/
- DX12中应该做和不应该做的事情：https://developer.nvidia.com/dx12-dos-and-donts

- Vulkan 内存管理 ：https://www.youtube.com/watch?v=rXSdDE7NWmA
- https://www.khronos.org/assets/uploads/developers/library/2018-vulkan-devday/03-Memory.pdf

### 
