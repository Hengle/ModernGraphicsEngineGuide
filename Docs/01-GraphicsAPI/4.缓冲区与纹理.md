# 缓冲区与纹理

## 缓冲区

缓冲区（Buffer）持有一段GPU上的内存（Memory）以及一些相关参数（**类型（Type）** 和 **用途（Usage）**）

**类型（Type）** 决定的Buffer的存储特性，图形API一般将其划分为：

- **Host Local Memory** ：只对Host可见的内存，通常称之为普通内存
- **Device Local Memory** ：只对Device可见的内存，通常称之为显存
- **Host Local Device Memory** ：由Host管理的，对Device看见的内存
- **Device Local Host Memory** ：由Device管理的，对Host可见的内存

> Host 往往是 CPU端， Device 指 GPU 端

关于细节，请查阅：

- [Vulkan 内存管理](https://zhuanlan.zhihu.com/p/166387973)

使用合适的内存类型能大幅提升内存的读写效率，在现代图形引擎中的流水线中，会尽可能地使用 **Device Memory** ，当我们要从CPU中提交数据给它时，由于Host无法访问，一般会将数据上传到一个 **Host可见的Memroy** 上，再通过指令拷贝到对应的 **Device Memory** 上，我们一般称这个持有主机可见内存的Buffer为 [Staging Buffer](https://link.zhihu.com/?target=https%3A//vulkan-tutorial.com/Vertex_buffers/Staging_buffer)

在 **用途（Usage）** 上，Buffer 通常可具备以下 **标识（Flag）** ：

- **VertexBuffer** ：用于存放顶点数据
- **IndexBuffer** ：用于存放索引数据
- **UniformBuffer** ：用于存储常量数据
- **StorageBuffer** ：用于Compute管线中的数据计算
- **IndirectDrawBuffer** ：用于间接渲染提供渲染参数

在图形渲染管线章节中，我们使用QRhi很轻松地创建了一个用于存储顶点数据的缓冲区（**VertexBuffer**）：

``` c++
QScopedPointer<QRhiBuffer> mVertexBuffer;   
mVertexBuffer.reset(mRhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(VertexData)));
mVertexBuffer->create(); //在QRhi中，调用渲染资源对象的create函数才实际创建对应的GPU资源，在这之前，我们都是调整参数状态机而已
```

只需要使用函数newBuffer就能申请一个新的缓冲区：

```c++
QRhiBuffer* QRhi::newBuffer(QRhiBuffer::Type type,
                      		QRhiBuffer::UsageFlags usage,
                      		quint32 size);
```

函数参数所代表的意义如下：

- **Type**：Buffer的类型，决定了Buffer的存储特性。

  - **Immutable** ：用于存放希望永远不会发生改变的数据，具有非常高效的GPU读写性能，它通常放置在 **Devices Local** 的 GPU 内存上，无法被CPU直接读写，但QRhi却支持它的上传，其原理是：每次上传数据新建一个 **Host Local** 的 **Staging Buffer** 作为中转来上传新数据，这样操作的代价是非常高昂的。

  - **Static** ：同样存储在 **Devices Local** 的 GPU 内存上，与 Immutable 不同的是，首次上传数据创建的 **Staging Buffer** 会一直保留。

  - **Dynamic** ：用于存放频繁发生变化的数据，它放置 **Host Local** 的GPU内存中，为了不拖延图形渲染管线，它通常会使用双缓冲机制。

- **Usage**：Buffer的用途，`Flags`说明是可以使用运算符`|`让多个`Flag`共存

  - **VertexBuffer**：表明该Buffer可作为顶点缓冲区，存储顶点数据，作为图形渲染管线的输入
  - **IndexBuffer**：表明该Buffer可作为索引缓冲区，存储索引数据，用于挑选顶点数据
  - **UniformBuffer**：表明该Buffer可作为Uniform缓冲区，存储Uniform数据，作为着色器的公共输入
  - **StorageBuffer**：表明该Buffer可作为Storage缓冲区，该缓冲区可被计算着色器读写

- **Size**：Buffer的事情大小（单位为字节）

### 顶点缓冲区

**顶点缓冲区（VertexBuffer）** 用作流水线的输入

在QRhi中，体现在录制渲染指令时必须为图形渲染管线指定顶点输入：

```c++
cmdBuffer->setGraphicsPipeline(mPipeline.get());							
cmdBuffer->setViewport(QRhiViewport(0, 0, mSwapChain->currentPixelSize().width(), mSwapChain->currentPixelSize().height()));
cmdBuffer->setShaderResources();										
const QRhiCommandBuffer::VertexInput vertexInput(mVertexBuffer.get(), 0);	//将 mVertexBuffer 绑定到Buffer0，内存偏移值为0
cmdBuffer->setVertexInput(0, 1, &vertexInput);								
cmdBuffer->draw(3);															
```

而在创建流水线的时候，必须为流水线设置**顶点输入布局（VertexInputLayout）**，它用于制定缓冲区的解析规则，在之前的章节中，我们使用了这样的顶点数据：

``` c++
static float VertexData[] = {										//顶点数据
	//position(xy)		color(rgba)
	 0.0f,  -0.5f,		1.0f, 0.0f, 0.0f, 1.0f,
	-0.5f,   0.5f,		0.0f, 1.0f, 0.0f, 1.0f,
	 0.5f,   0.5f,		0.0f, 0.0f, 1.0f, 1.0f,
};
```

为了让顶点数据能够被下面的 顶点着色器输入 使用：

``` glsl
layout(location = 0) in vec2 position;	
layout(location = 1) in vec4 color;
```

我们可以定义这样的顶点输入布局：

``` c++
QRhiVertexInputLayout inputLayout;
inputLayout.setBindings({		 //定义每个VertexBuffer单组顶点数据的跨度，这里只使用了一个VertexBuffer
    //这里是6*sizeof(float)，可以当作是GPU会从索引为0的Buffer中读取24字节数据作为单组顶点数据传给VertexShader
    QRhiVertexInputBinding(6 * sizeof(float)) 
});

inputLayout.setAttributes({
    //在从Buffer 0得到的单组顶点数据中，以偏移值为0，读取Float2大小的数据作为 location 0 的输入
    QRhiVertexInputAttribute(0, 0 , QRhiVertexInputAttribute::Float2, 0),
   
    //在从Buffer 0得到的单组顶点数据中，以偏移值为sizeof(float)*2，读取Float4大小的数据作为 location 1 的输入
    QRhiVertexInputAttribute(0, 1 , QRhiVertexInputAttribute::Float4, sizeof(float) * 2),	
});
```

在图形渲染的处理过程中，计算机关注的只是内存上的数据，并不在意这些数据的象征意义，正因为顶点输入布局的存在，使得我们可以编程时自行组织顶点的存储结构。

上面我们将所有的数据都放在了一个`float数组`中，现在我们可以使用一个更直观的结构：

``` c++
struct Vertex{					//顶点的结构
	QVector2D position;
	QVector4D color;
};
QVector<Vertex> vertices = {	//顶点数据
    { { 0.0f,  -0.5f},	{1.0f, 0.0f, 0.0f, 1.0f	}},
    { {-0.5f,   0.5f},	{0.0f, 1.0f, 0.0f, 1.0f	}},
    { { 0.5f,   0.5f},	{0.0f, 0.0f, 1.0f, 1.0f	}},
};
```

我们只需填充顶点数据，使用`sizeof(Vertex) * vertices.size()`创建顶点缓冲区：

```c++
QScopedPointer<QRhiBuffer> mVertexBuffer;   

mVertexBuffer.reset(mRhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(Vertex) * vertices.size()));
mVertexBuffer->create(); 
```

并使用这样的顶点输入布局：

```c++
QRhiVertexInputLayout inputLayout;
inputLayout.setBindings({	
    QRhiVertexInputBinding(sizeof(Vertex)) 		//单个顶点数据的跨度也就是Vertex结构的大小
});

inputLayout.setAttributes({
    QRhiVertexInputAttribute(0, 0 , QRhiVertexInputAttribute::Float2, offsetof(Vertex,position)),
    QRhiVertexInputAttribute(0, 1 , QRhiVertexInputAttribute::Float4, offsetof(Vertex,color)),	
});
```

> **offsetof**运算符可用于获取成员变量在结构体或类中的内存偏移

上传时使用数组的裸数据即可：

```c++
batch->uploadStaticBuffer(mVertexBuffer.get(), mVertices.data());
```

### 索引缓冲区

**索引缓冲区（IndexBuffer）**用于挑选输入到流水线中的顶点数据

一个通用的应用场景是：

- 由于图形API支持的基础图元只有点，线和三角形，在绘制多边形的时候，会使用多个三角形进行拼接，以四边形为例，一个四边形可划分为两个三角形，而两个三角形有六个顶点，但实际上四边形只有四个顶点，如果使用三角形拼接，会需要浪费两个顶点数据的空间大小来存储重叠的顶点，所有我们需要一种策略，来复用顶点缓冲区中的顶点数据，以完成 使用四个顶点就能绘制出由两个三角形组成的四边形。

流水线处理顶点输入时，会根据顶点输入布局，将顶点缓冲区中的数据划分成一组组有序的顶点数据，在**默认情况**下，会将这些顶点数据都交给VertexShader进行处理。

而索引缓冲区的作用，就是在划分成一组组有序的顶点数据之后，通过一系列索引（Index），在原先的顶点数据上进行挑选，组装出新的顶点数据交给VertexShader处理。

假如我们使用这样的顶点数据：

``` c++
static float VertexData[] = {
	//position(xy)
	 1.0f,   1.0f,
	 1.0f,  -1.0f,
	-1.0f,  -1.0f,
	-1.0f,   1.0f,	
};
```

可以使用这样的索引数据，从上述顶点中，使用6个索引来组装新的顶点数据：

```c++
static uint32_t IndexData[] = {
	0,1,2,
	2,3,0
};
```

与VertexBuffer一样，我们只需创建一个IndexBuffer：

```c++
QScopedPointer<QRhiBuffer> mIndexBuffer;

mIndexBuffer.reset(mRhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::IndexBuffer, sizeof(IndexData)));
mIndexBuffer->create();
```

并在首次录制渲染指令时提交索引数据：

```c++
batch->uploadStaticBuffer(mIndexBuffer.get(), IndexData);
```

渲染指令变成了：

```c++
cmdBuffer->setGraphicsPipeline(mPipeline.get());
cmdBuffer->setViewport(QRhiViewport(0, 0, mSwapChain->currentPixelSize().width(), mSwapChain->currentPixelSize().height()));
cmdBuffer->setShaderResources();
const QRhiCommandBuffer::VertexInput vertexBindings(mVertexBuffer.get(), 0);

//指定IndexBuffer，并明确IndexBuffer使用UInt32格式的索引数据
cmdBuffer->setVertexInput(0, 1, &vertexBindings, mIndexBuffer.get(), 0, QRhiCommandBuffer::IndexUInt32);  

//使用drawIndexed而不是draw，这样渲染会从IndexBuffer中，读取6个索引，利用顶点缓冲区中数据组装出6个顶点，来绘制三角形
cmdBuffer->drawIndexed(6);
```

### Uniform 缓冲区

**Uniform 缓冲区（Uniform Buffer）**用于给流水线提供一些着色器公共的只读数据。

在QRhi中，可以使用如下代码来创建一个UniformBuffer：

``` c++
QScopedPointer<QRhiBuffer> mUniformBuffer;   

mUniformBuffer.reset(mRhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, mUniformBuffer));
mUniformBuffer->create();
```

- UniformBuffer 的类型必须是  `QRhiBuffer::Dynamic`
- `UniformBufferSize` 表示所需缓冲区的字节大小

通常在创建UniformBuffer的时候，我们不会直接使用`UniformBufferSize` 来创建一块内存，而是通过一个辅助的结构体定义，比如：

```c++
struct UniformBlock{
	QVector2D mousePos;
	float time;
};

//...
mUniformBuffer.reset(mRhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, sizeof(UniformBlock)));
//...
```

这样做的好处是：可以通过结构体定义来给这段内存一些直观的结构

比如上述结构体中，一共申请了`12字节`的内存，其中`前8字节`存储了一个二维向量，`后4字节`存储了一个浮点。

要使用UniformBlock，需要在流水线的 着色器资源绑定（即描述符集布局）中，添加一个绑定项：

```c++
mShaderBindings.reset(mRhi->newShaderResourceBindings());
mShaderBindings->setBindings({
	QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::StageFlag::FragmentStage, mUniformBuffer.get())
});
mShaderBindings->create();
```

- QRhiShaderResourceBinding中提供了一些静态方法添加着色器资源绑定项，这里我们使用静态函数`QRhiShaderResourceBinding::uniformBuffer()`
- `0`代表绑定的索引
- `QRhiShaderResourceBinding::StageFlag::VertexStage`表示该UniformBlock可以在片段着色阶段使用，`Flag`表明这是一个可组合的标识。

在C++代码中有了上述结构的支撑，就可以在顶点着色器中使用UniformBuffer的数据，为了能够正确解析UniformBuffer中的内存结构，我们在Shader中定义了一个与C++结构体内存布局一样的 [接口块 （Interface Block）](https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL))：

```c++
QShader vs = mRhi->newShaderFromCode(QShader::FragmentStage, R"(#version 440
    layout(binding = 0) uniform UniformBlock{	// 0 与 ShaderResourceBinding 的定义对应
        vec2 mousePos;
        float time;
    }UBO;
    //...
)");
Q_ASSERT(vs.isValid());
```

上面是一种简单的写法，下面的写法对大家来说可能会更亲切一些：

```c++
QShader vs = mRhi->newShaderFromCode(QShader::FragmentStage, R"(#version 440
	struct UniformBlock{
        vec2 mousePos;
        float time;
	};
    layout(binding = 0) uniform UniformBlock UBO;
    //...
)");
Q_ASSERT(vs.isValid());
```

提交UniformBlock数据的方式跟其他Buffer大同小异：

``` c++
UniformBlock ubo;
ubo.mousePos = QVector2D(mapFromGlobal(QCursor::pos())) * qApp->devicePixelRatio();		//获取鼠标位置
ubo.time = QTime::currentTime().msecsSinceStartOfDay() / 1000.0f;						//获取当前时间
batch->updateDynamicBuffer(mUniformBuffer.get(), 0, sizeof(UniformBlock), &ubo);
```

在上述代码中，我们使用了这样的结构体定义：

```c++
struct UniformBlock{		//c++
	QVector2D mousePos;
	float time;
};

struct UniformBlock{		// shader
    vec2 mousePos;
    float time;
};
```

需要注意的是，在Shader中定义的块结构，图形API可能会在块成员之间做一些填充来保持硬件对齐，还可能优化掉未使用的成员。

在上述结构中，假如我们更换`vec2 mousePos;`和 `float time;`位置，

```c++
struct UniformBlock{		//c++
    float time;
	QVector2D mousePos;
};

struct UniformBlock{		// shader
    float time;
    vec2 mousePos;
};
```

虽然在结构定义上看上去他们是一样的，但在内存布局上，却有着严重的差异。

以OpneGL为例，OpenGL中要求`vec2`遵循`8字节`对齐，这就导致shader中UniformBlock的结构定义，`time`和`mousePos`之间会填充`4字节`以保证`mousePos`是`8字节`对齐，这也意味着shader端的结构体，实际大小并非`12字节`，而是`16字节`，如果此时C++还当成是`12字节`进行处理，就会导致C++端上传的Uniform数据，跟Shader这边收到的数据对不上。

要解决这个问题，比较粗暴的方式是在C++侧去手动填充数据来保证对齐：

```C++
struct UniformBlock{		//c++
    float time;
   	uint32_t __padding; 	//该变量用于填充对齐,保证跟Shader中内存结构的一致
	QVector2D mousePos;
};

struct UniformBlock{		// shader
    float time;
    vec2 mousePos;
};
```

在C++11中，提供了更优雅的方式—— [alignas](https://en.cppreference.com/w/cpp/language/alignas)

```c++
struct UniformBlock{		//c++
	float time;
	alignas(8) QVector2D mousePos;		//使用alignas指定该成员使用8字节对齐
};

struct UniformBlock{		// shader
    float time;
    vec2 mousePos;
};
```

关于缓冲区对齐，这里有一些更详细的资料：

- [Learn OpenGL Uniform Block Layout](https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/08%20Advanced%20GLSL/#uniform_1)
- [OpenGL Wiki - Interface_Block ](https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Memory_layout)

### Storage 缓冲区

**Storage 缓冲区（Storage Buffer）**用于在计算管线（Compute Pipelines）中提供可读可写的数据。

它的用法与UniformBuffer几乎一模一样，它们之间的主要区别是：

- **Storage Buffer 可以申请非常大的显存**： OpenGL 规范保证 Uniform Buffer 的大小可以达到 **16KB**，而 Storage Buffer 可以达到  **128 MB**。
- **Storage Buffer 是可写的，甚至支持原子（Atomic）操作**：Storage Buffer 的读写可能是乱序的，因此它们往往需要增加一些内存屏障来保证同步。
- **Storage Buffer 支持可变存储**：这意味着在Storage Buffer中的块（Block），可以定义一个无界数组，就像是 `int arr[];`， 在着色器中可以使用`arr.length`得到数组长度，而在 Uniform Buffer 中的块，在定义数组时需要明确指定数组大小。
- **相同条件下，SSBO的访问会比Uniform Buffer要慢**：Storage Buffer 通常像缓冲区纹理一样访问，而 Uniform Buffer 数据是通过内部着色器可访问的内存进行读取。

在后面的计算着色器章节，会讲解它的使用，这里有一个完善的文档：

- https://www.khronos.org/opengl/wiki/Shader_Storage_Buffer_Object

## 纹理

### 采样器

## 内存管理

- Vulkan中应该做和不应该做的事情：https://developer.nvidia.com/blog/vulkan-dos-donts/
- DX12中应该做和不应该做的事情：https://developer.nvidia.com/dx12-dos-and-donts

- Vulkan 内存管理 ：https://www.youtube.com/watch?v=rXSdDE7NWmA
- https://www.khronos.org/assets/uploads/developers/library/2018-vulkan-devday/03-Memory.pdf

### 
