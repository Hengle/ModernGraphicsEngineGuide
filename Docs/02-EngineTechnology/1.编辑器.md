# 编辑器开发

笔者近几年开发中的绝大部分代码积累，都花在了引擎编辑器上，在此处罗列一些心得，希望能给大家一些参考。

本文将围绕两个问题来展开：

- 怎么做编辑器？
- 怎么做好编辑器？

## 怎么做编辑器



## 怎么做好编辑器

笔者接触过一些自研引擎，只要涉及到自研引擎 **编辑器相关** 的 话题，那下面基本就是骂声一片~~~

究其原因，无外乎：

- 界面简陋
- 用户体验差

而大部分开发者的想法是：

- “并不是不能做好，只是要做好得花很多时间，会很麻烦，没必要浪费时间，将就能用就行了。”

当然，这种想法对一些小工具来说无可厚非，但是对于一些高频使用的工具，如果还是这样的做法，那对使用人员来说，简直就是一场灾难性的折磨。。。

笔者在Qt上有数十万行代码的积累，但在Unreal Engine上只使用了数万行的代码，却出做出了更多更完备的功能，并且在Unreal Engine中，界面风格和用户体验的需求是非常容易满足的，这很大程度得益于 Unreal Engine 的 “基础建设” ，具体而言 ：

- 强大的反射系统和基于反射的编辑器架构。

下面从以下几个维度去分析怎么去做好编辑器：

### 设计美感

设计美感是大多数开发者所欠缺的东西，因为他们在代码上花费了非常多的心思，很少会愿意绞尽脑汁去思考怎样去制作出精美的界面。

当然，虽然他们没有一个懂得设计的大脑，但却也长了一双欣赏美丽事物的眼睛，只要有合适的参考，开发者们能很快的复刻出相应的效果。

而在大对数公司中，软件开发团队中往往会有专业的UI设计师，他们主要关注UI的：

- 排版
- 色调
- 图标
- 布局

在笔者见过的一些程序中，虽然说确实考虑了以上几点，制作出了精美的界面效果，但往往忽略了UI的 **组件化设计**，从而导致：

- 用户无法快速建立起软件的使用规律，增加了认知负担。
- 破坏软件的组织架构，一个组件化设计优秀的UI，可以从界面上看出代码的层次结构，一个条例混乱的界面，它的代码往往也是乱作一团。

关于UI设计上的一些概念和风格，可以参考：

- [All Time Design - UI  Style Guide](https://alltimedesign.com/ui-style-guide/)

在游戏引擎中，由于引擎的界面相对而言比较复杂，所以在关注界面美观程度的同时，还要尽可能减少界面产生的性能损耗，不要去使用一些性能损耗比较高的界面效果，如模糊，阴影，拟态，毛玻璃，投影...

### 用户体验

关于用户体验，主要围绕：

- 减少用户的认知负担：在布局，命名，操作上遵循一些常识和规范
- 支持撤销，重做：让一些误操作能够被快速修正
- 合理的操作反馈：当执行一些操作时，可以使用日志，对话框，进度条，通知气泡，状态栏...来告知用户 操作的执行状态
- 及时的状态备份或保存：避免意料之外的崩溃导致大量工作数据的丢失
- 可配置的操作方式：让用户可以自定义快捷键，布局方式，操作风格等

关于减少用户的认知负担，这里有一个非常完善的文档：

- [O3DE - Component Card UX Pattern](https://docs.o3de.org/docs/tools-ui/ux-patterns/component-card/)

- [O3DE - Component Card Error Handling](https://docs.o3de.org/docs/tools-ui/ux-patterns/error/)

关于撤销重做，它是一个代码设计的问题，通常情况下，我们会在设计模式上使用备忘录模式和命令模式来实现撤销重做功能，这在Qt中对应的结构是 **QUndoCommand** 和 **QUndoStack**，其中**QUndoCommand**的核心定义如下：

``` c++
class QUndoCommand
{
    virtual void undo();
    virtual void redo();
    virtual int id() const;
    virtual bool mergeWith(const QUndoCommand *other);
}；
```

在使用时，我们会派生QUndoCommand，覆写函数去实现undo和redo的操作行为，之后再将具体的Command推入到UndoStack中。

这是一个简单的代码示例：

``` c++
#include <QUndoCommand>
#include <QUndoStack>
#include <QDebug>

class QAssignCommand : public QUndoCommand {
public:
	QAssignCommand(int* ptr, int dstValue)
		: mValuePtr(ptr)
		, mSrcValue(*ptr)
		, mDstValue(dstValue) {}
protected:
	virtual void undo() override {
		*mValuePtr = mSrcValue;
	}
	virtual void redo() override {
		*mValuePtr = mDstValue;
	}
private:
	int* mValuePtr = nullptr;
	int mSrcValue;
	int mDstValue;
};

int main(int argc, char** argv) {
	QUndoStack stack;
	int value = 0;
	stack.push(new QAssignCommand(&value, 1));
	qDebug() << value;		//1
	
	stack.undo();
	qDebug() << value;		//0
	
	stack.redo();
	qDebug() << value;		//1

	stack.beginMacro("Merge");	
	stack.push(new QAssignCommand(&value, 2));
	stack.push(new QAssignCommand(&value, 3));
	stack.endMacro();
	qDebug() << value;		//3

	stack.undo();
	qDebug() << value;		//1

	return 0;
}
```

它的实现思路比较简单，但也有一些比较难处理的点：

- Command中操作对象如果在其他地方被销毁了，但Command还存在于Stack中，如果此时执行撤销重做，可能会导致程序的崩溃

对于这种问题，我们主要可以通过以下几个方案去解决：

- 考虑是不是撤销重做操作的指令没有完全覆盖操作对象的生命周期

- 为Command增加有效性验证
- 使用序列化 对 对象 进行保存和还原

在Unreal Engine，提供了一种基于对象系统的撤销重做机制 ——**Transactional**

对于任意携有`RF_Transactional`标识的UObject实例，都可以使用如下代码来实现撤销重做

``` c++
GEditor->BeginTransaction(FText::FromString("Assign Value"));	//开始事务

MyObject->Modify();												//保存初始状态
MyObject->ValueProperty = 123;									//修改属性

GEditor->EndTransaction();										//结束事务
```

由于UObject的GC可以让对象延迟回收，这也使得我们无需考虑操作对象生命周期的问题，关于它的实现原理，详见：

- [UE4 编辑器(UObject)的Undo撤回系统Transactional](https://blog.csdn.net/qq_29523119/article/details/96778797)

关于状态保存，相信大家都遇到过程序突然崩溃或者电脑突然关机的情况，这个时候如果没有及时的保存工作数据，几小时的精力就得打水漂了，而这个时候，如果程序提供保存或备份的辅助手段，关键时刻能帮上大忙~

而这种手段一般是指自动保存，除了让用户手动点击去保存工作数据，我们还可以在特定时机去自动保存或备份工作数据，就比如：

- 用户关闭某个界面时进行保存
- 定时自动保存
- 程序崩溃时保存（使用`SetUnhandledExceptionFilter`函数可设置程序崩溃时的系统回调）

上述手段可以尽可能的减少工作数据丢失的风险，当然，对于一些保存性能损耗不大的数据，比如小型配置文件，我们可以在执行完操作后，立即保存。

### 操作性能

### Meta思维

#### 基于反射的对象编辑器

### 开发管理

