# 音频开发

长久以来，渲染效果一直是图形引擎的关键核心，而音频似乎很难吸引开发者的注意力，但实际上，但对于游戏而言，音频除了可以增加沉浸交互体验，还能增加不少趣味性。



[有哪些国内的游戏使用了音频引擎来做音频部分的开发？比如FMOD和wwise? - 知乎 (zhihu.com)](https://www.zhihu.com/question/29992299)

[Sounds Good: Unreal Engine Audio | Unreal Fest 2023](https://www.bilibili.com/video/BV1EC4y1J7Bs)

[WAV文件格式解析及处理 - 简书 (jianshu.com)](https://www.jianshu.com/p/63d7aa88582b)

[Musiscope (sciencemusic.org)](https://oscilloscope.sciencemusic.org/)

``` c++
#include <stdint.h>
#include <assert.h>
#include <map>
#include <vector>
#include <functional>
#include <string>
#include <fstream>
#include <algorithm>
#include <iostream>

struct WaveFmtChunk {
	unsigned char chunkID[4] = {'f','m','t',' '};
	int32_t chunkSize;
	int16_t audioFormat;
	int16_t numChannels;
	int32_t sampleRate;
	int32_t byteRate;
	int16_t blockAlign;
	int16_t bitsPerSample;
};

struct WaveDataChunkHeader{
	unsigned char chunkID[4] = {'d','a','t','a'};
	int32_t chunkSize;
};

struct WaveRiffChunk{
	unsigned char chunkID[4] = { 'R','I','F','F' };
	int32_t chunkSize;
	unsigned char format[4] = {'W','A','V','E'};
	WaveFmtChunk fmtChunk;
	WaveDataChunkHeader dataChunkHeader;
};

typedef WaveRiffChunk WaveHeader;
const int PCMS8MaxAmplitude = 128;
const int PCMS16MaxAmplitude = 32767; 
const int PCMS24MaxAmplitude = 8388608;
const int PCMS32MaxAmplitude = 2147483648;

typedef std::function<void(unsigned char*, float)> AmplitudeWriteFunction;
static std::map<unsigned char, AmplitudeWriteFunction> AmplitudeWriteFunctions = {
	{8,[](unsigned char* dataPtr, float amplitude) {
		int8_t value = amplitude * PCMS8MaxAmplitude;
		dataPtr[0] = value & 0xFF;
	}},
	{16,[](unsigned char* dataPtr, float amplitude) {
		int16_t value = amplitude * PCMS16MaxAmplitude;
		dataPtr[0] = value & 0xFF;
		dataPtr[1] = (value >> 8) & 0xFF;
	}},
	{24,[](unsigned char* dataPtr, float amplitude) {
		int value = amplitude * PCMS24MaxAmplitude;
		dataPtr[0] = value & 0xFF;
		dataPtr[1] = (value >> 8) & 0xFF;
		dataPtr[2] = (value >> 16) & 0xFF;
	}},
	{32,[](unsigned char* dataPtr, float amplitude) {		
		int32_t value = amplitude * PCMS32MaxAmplitude;
		dataPtr[0] = value & 0xFF;
		dataPtr[1] = (value >> 8) & 0xFF;
		dataPtr[2] = (value >> 16) & 0xFF;
		dataPtr[3] = (value >> 24) & 0xFF;
	}}
};

typedef std::function<float(unsigned char*)> AmplitudeReadFunction;
static std::map<unsigned char, AmplitudeReadFunction> AmplitudeReadFunctions = {
	{8,[](unsigned char* dataPtr) {
		return (*reinterpret_cast<int8_t*>(dataPtr)) / float(PCMS8MaxAmplitude);
	}},
	{16,[](unsigned char* dataPtr) {
		return (*reinterpret_cast<int16_t*>(dataPtr)) / float(PCMS16MaxAmplitude);
	}},
	{24,[](unsigned char* dataPtr) {
		int value = dataPtr[2];
		value <<= 8;
		value |= dataPtr[1];
		value <<= 8;
		value |= dataPtr[0];
		return value / float(PCMS24MaxAmplitude);
	}},
	{32,[](unsigned char* dataPtr) {
		return (*reinterpret_cast<int32_t*>(dataPtr)) / float(PCMS32MaxAmplitude);
	}}
};

const double MATH_PI = 3.1415926535;

int MakeWaveData2(int freq, float amp, int time_ms, unsigned char* p, int len, int sampleRate = 44100, int channels = 2, int BitsPerSample = 16)
{
	int ret = 0;
	int SAMPLE_NUM = sampleRate * time_ms / 1000; //采集样本总数
	int AUDIO_CYCLE = sampleRate / freq; //一个正弦波采集样本个数
	int ACCURACY = (BitsPerSample == 16) ? INT16_MAX : INT8_MAX;  //精度
	//int BUFF_SIZE = sampleRate * durations * channels * BitsPerSample/8;
	if (amp > 1.0) {
		amp = 1.0;
	}
	else if (amp <= 0.01) {
		amp = 0.01;
	}

	for (int i = 0; i < SAMPLE_NUM; i++) { //实际上只要采集AUDIO_CYCLE 个点就可以得到一个完整正弦波
		float Time = i / (float)SAMPLE_NUM * time_ms;
		int16_t v = (int16_t)(amp * ACCURACY * sin(2 * MATH_PI * (i % AUDIO_CYCLE * 1.0) / AUDIO_CYCLE)); //正弦函数y = k sin x
		if (BitsPerSample == 16) {//16位
			if (channels == 1) {//16位单通道
				p[i * 2] = (v & 0xFF);           //低字节在前 16bits量化，低字节8位
				p[1 + i * 2] = ((v >> 8) & 0xFF); //高字节在后，高字节8位
			}
			else {//16位双通道
				p[i * 4] = (v & 0xFF);           //低字节在前 16bits量化，低字节8位
				p[1 + i * 4] = ((v >> 8) & 0xFF); //高字节在后，高字节8位
				p[2 + i * 4] = (v & 0xFF);           //低字节在前 16bits量化，低字节8位
				p[3 + i * 4] = ((v >> 8) & 0xFF); //高字节在后，高字节8位
			}

		}
		else {
			if (channels == 1) {//8位单通道
				p[i] = (v & 0xFF);
			}
			else {//8位双通道
				p[i * 2] = (v & 0xFF);
				p[1 + i * 2] = (v & 0xFF);
			}
		}
	}

	return ret;
}

void writeWaveFile(std::string filePath) {
	assert(sizeof(WaveHeader) == 44);
	WaveHeader header;
	header.fmtChunk.audioFormat = 0x0001;	// PCM格式对应的数值为0x0001
	header.fmtChunk.chunkSize = 16;			// PCM格式的音频格式占16字节，如果是其他格式，可能会>16,即总的文件头大小>44
	header.fmtChunk.numChannels = 1;		// 单身道
	header.fmtChunk.bitsPerSample = 16;		// 每个音频样本占8Bit，即1字节
	header.fmtChunk.sampleRate = 48000;		// 采样率为48000HZ
	header.fmtChunk.blockAlign = header.fmtChunk.numChannels * header.fmtChunk.bitsPerSample / 8;
	header.fmtChunk.byteRate = header.fmtChunk.sampleRate * header.fmtChunk.blockAlign;

	auto generateSineWave= [](int timeLengthSec,int frequency, float amplitude, int numChannels, int sampleRate, int bitsPerSample) {
		int numBlocks = timeLengthSec * sampleRate;
		amplitude = std::clamp(amplitude, 0.01f, 1.0f);
		std::vector<unsigned char> audioData;
		audioData.resize(numBlocks * numChannels * bitsPerSample / 8);
		int step = bitsPerSample / 8;
		unsigned char* audioDataPtr = audioData.data();
		AmplitudeWriteFunction writer = AmplitudeWriteFunctions.at(bitsPerSample);
		std::string before;
		for (int i = 0; i < numBlocks; i++) {
			float time = i / (float)numBlocks * timeLengthSec;
			float value = sin(2 * MATH_PI * frequency * time);
			for (int j = 0; j < numChannels; j++) {
				writer(audioDataPtr, value);
				audioDataPtr += step;
			}
		}
		//std::cout << before <<std::endl;

		std::string after;
		for (auto data : audioData) {
			after += std::to_string(data) + ",";
		}	
		std::cout << after << std::endl;
		return audioData;
	};
	//std::vector<unsigned char> audioData = generateSineWave(2, 440, 0.8f, header.fmtChunk.numChannels, header.fmtChunk.sampleRate, header.fmtChunk.bitsPerSample);

	std::vector<unsigned char> audioData;
	audioData.resize(2 * header.fmtChunk.sampleRate * header.fmtChunk.numChannels * header.fmtChunk.bitsPerSample / 8);
	MakeWaveData2(480, 1.0f, 2000, audioData.data(), audioData.size(), header.fmtChunk.sampleRate, header.fmtChunk.numChannels, header.fmtChunk.bitsPerSample);

	header.dataChunkHeader.chunkSize = audioData.size();
	header.chunkSize = sizeof(header.format) + sizeof(header.fmtChunk) + sizeof(header.dataChunkHeader) + audioData.size();;
	std::ofstream out(filePath);
	out.write(reinterpret_cast<char*>(&header), sizeof(WaveHeader));
	out.write(reinterpret_cast<char*>(audioData.data()), audioData.size());
	out.close();
}

std::vector<unsigned char> readWaveFile(std::string filePath) {
	std::ifstream in(filePath);
	WaveHeader header;
	in.read(reinterpret_cast<char*>(&header), sizeof(header));
	std::vector<unsigned char> audioData;
	return audioData;
}

int main() {
	writeWaveFile("./test.wav");
	std::vector<unsigned char> audioData = readWaveFile("./123_1.wav");
	return 0;
}
```

