# 音频开发

长久以来，渲染一直是图形引擎的热点，而音频似乎很难吸引开发者的注意力，但实际上，对于游戏而言，音频除了可以增加沉浸式的交互体验，还能增加不少趣味性，就像这样：



笔者也正是因此，点燃了对程序开发的热情，为了让音频能有更好的图形表现效果，这才入了图形引擎的坑~

本篇文章会从基础的音频知识开始讲解，并介绍常见的 **数字信号处理（Digital Signal Process）** 算法，

以及最后 —— 拥抱 **Meta Sound**。

> 笔者并非专业的音频开发人员，如有纰漏，烦请赐教~

## 认识音频

众所周知，声音是由震动产生的，就像是这样：

![Sound Waves](Resources/loudspeaker-waveform.gif)

这里有一个通俗的视频讲解了声音的本质：

<iframe src="//player.bilibili.com/player.html?aid=339069532&bvid=BV1pR4y1L7WD&cid=507834923&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



https://zhuanlan.zhihu.com/p/550072985

[有哪些国内的游戏使用了音频引擎来做音频部分的开发？比如FMOD和wwise? - 知乎 (zhihu.com)](https://www.zhihu.com/question/29992299)

[Sounds Good: Unreal Engine Audio | Unreal Fest 2023](https://www.bilibili.com/video/BV1EC4y1J7Bs)

[WAV文件格式解析及处理 - 简书 (jianshu.com)](https://www.jianshu.com/p/63d7aa88582b)

[Musiscope (sciencemusic.org)](https://oscilloscope.sciencemusic.org/)

``` c++
#include <stdint.h>
#include <assert.h>
#include <map>
#include <vector>
#include <functional>
#include <string>
#include <fstream>
#include <algorithm>
#include <iostream>

struct WaveFmtChunk {
	unsigned char chunkID[4] = { 'f','m','t',' ' };
	int32_t chunkSize;
	int16_t audioFormat;
	int16_t numChannels;
	int32_t sampleRate;
	int32_t byteRate;
	int16_t blockAlign;
	int16_t bitsPerSample;
};

struct WaveDataChunkHeader {
	unsigned char chunkID[4] = { 'd','a','t','a' };
	int32_t chunkSize;
};

struct WaveRiffChunk {
	unsigned char chunkID[4] = { 'R','I','F','F' };
	int32_t chunkSize;
	unsigned char format[4] = { 'W','A','V','E' };
	WaveFmtChunk fmtChunk;
	WaveDataChunkHeader dataChunkHeader;
};

typedef WaveRiffChunk WaveHeader;

const int PCMS8MaxAmplitude	 = 127;
const int PCMS16MaxAmplitude = 32767;
const int PCMS24MaxAmplitude = 8388607;
const int PCMS32MaxAmplitude = 2147483647;

typedef std::function<void(unsigned char*, float)> SampleValueWriteFunction;
static std::map<unsigned char, SampleValueWriteFunction> SampleValueWriteFunctions = {
	{8,[](unsigned char* dataPtr, float sampleValue) {
		(*reinterpret_cast<int8_t*>(dataPtr)) = sampleValue * PCMS8MaxAmplitude + PCMS8MaxAmplitude;
	}},
	{16,[](unsigned char* dataPtr, float sampleValue) {
		(*reinterpret_cast<int16_t*>(dataPtr)) = sampleValue * PCMS16MaxAmplitude;
	}},
	{24,[](unsigned char* dataPtr, float sampleValue) {
		int value = sampleValue * PCMS24MaxAmplitude;
		dataPtr[0] = value & 0xFF;
		dataPtr[1] = (value >> 8) & 0xFF;
		dataPtr[2] = (value >> 16) & 0xFF;
	}},
	{32,[](unsigned char* dataPtr, float sampleValue) {
		(*reinterpret_cast<int32_t*>(dataPtr)) = sampleValue * PCMS32MaxAmplitude;
	}}
};

typedef std::function<float(unsigned char*)> SampleValueReadFunction;
static std::map<unsigned char, SampleValueReadFunction> SampleValueReadFunctions = {
	{8,[](unsigned char* dataPtr) {
		return ((*reinterpret_cast<int8_t*>(dataPtr)) - PCMS8MaxAmplitude) / float(PCMS8MaxAmplitude);
	}},
	{16,[](unsigned char* dataPtr) {
		return (*reinterpret_cast<int16_t*>(dataPtr)) / float(PCMS16MaxAmplitude);
	}},
	{24,[](unsigned char* dataPtr) {
		int value = dataPtr[2];
		value <<= 8;
		value |= dataPtr[1];
		value <<= 8;
		value |= dataPtr[0];
		return value / float(PCMS24MaxAmplitude);
	}},
	{32,[](unsigned char* dataPtr) {
		return (*reinterpret_cast<int32_t*>(dataPtr)) / float(PCMS32MaxAmplitude);
	}}
};

const double MATH_PI = 3.1415926535;

std::vector<unsigned char> generateSineWave(int timeLengthSec, int frequency, float amplitude, int numChannels, int sampleRate, int bitsPerSample) {
	int numBlocks = timeLengthSec * sampleRate;
	amplitude = std::clamp(amplitude, 0.01f, 1.0f);
	std::vector<unsigned char> audioData;
	audioData.resize(numBlocks * numChannels * bitsPerSample / 8);
	int step = bitsPerSample / 8;
	unsigned char* audioDataPtr = audioData.data();
	SampleValueWriteFunction writer = SampleValueWriteFunctions.at(bitsPerSample);
	std::string before;
	for (int i = 0; i < numBlocks; i++) {
		double time = i / (double)numBlocks * timeLengthSec;
		float sampleValue = amplitude * std::sin(2 * MATH_PI * frequency * time);
		for (int j = 0; j < numChannels; j++) {
			writer(audioDataPtr, sampleValue);
			audioDataPtr += step;
		}
	}
	return audioData;
}

void writeWaveFile(std::string filePath, int numChannels, int sampleRate, int bitsPerSample, std::vector<unsigned char> audioData) {
	WaveHeader header;
	header.fmtChunk.audioFormat		= 0x0001;			// PCM格式对应的数值为0x0001
	header.fmtChunk.chunkSize		= 16;				// PCM格式的音频格式占16字节，如果是其他格式，可能会>16,即总的文件头大小>44
	header.fmtChunk.numChannels		= numChannels;		
	header.fmtChunk.bitsPerSample	= bitsPerSample;		
	header.fmtChunk.sampleRate		= sampleRate;		
	header.fmtChunk.blockAlign		= header.fmtChunk.numChannels * header.fmtChunk.bitsPerSample / 8;
	header.fmtChunk.byteRate		= header.fmtChunk.sampleRate * header.fmtChunk.blockAlign;
	header.dataChunkHeader.chunkSize = audioData.size();
	header.chunkSize = sizeof(header.format) + sizeof(header.fmtChunk) + sizeof(header.dataChunkHeader) + audioData.size();
	std::ofstream out(filePath, std::ios::out | std::ios::binary);		//务必使用std::ios::binary，否则数据错乱
	out.write(reinterpret_cast<char*>(&header), sizeof(WaveHeader));
	out.write(reinterpret_cast<char*>(audioData.data()), audioData.size());
	out.close();
}

std::vector<unsigned char> readWaveFile(std::string filePath) {
	std::ifstream in(filePath , std::ios::in | std::ios::binary);		//务必使用std::ios::binary，否则数据错乱
	WaveHeader header;
	in.read(reinterpret_cast<char*>(&header), sizeof(header));
	std::vector<unsigned char> audioData(header.dataChunkHeader.chunkSize);
	in.read(reinterpret_cast<char*>(audioData.data()), header.dataChunkHeader.chunkSize);
	return audioData;
}

int main() {
	assert(sizeof(WaveHeader) == 44 && "Wave Header Size Error");

	int numChannels = 1;			//单通道
	int sampleRate = 48000;			//采样率为48000HZ
	int bitsPerSample = 16;			//每个音频样本占16Bit，即2字节
	int auidoLengthSec = 2;			//生成2s的正弦波
	int sineFrequency = 440;		//正弦波的频率
	float sineAmplitude = 0.8f;		//正弦波的振幅

	std::vector<unsigned char> audioData = generateSineWave(auidoLengthSec, sineFrequency, sineAmplitude, numChannels, sampleRate, bitsPerSample);



	writeWaveFile("./test.raw", numChannels, sampleRate, bitsPerSample, audioData);

	std::vector<unsigned char> readData = readWaveFile("./test.wav");

	assert(readData == audioData && "Audio Data Error");

	return 0;
}
```

